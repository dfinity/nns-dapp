{
  "neuron_state": {
    "Unspecified": "",
    "Locked": "Locked",
    "Spawning": "Spawning",
    "Dissolved": "Unlocked",
    "Dissolving": "Dissolving"
  },
  "topics": {
    "Unspecified": "Unspecified",
    "NeuronManagement": "Neuron Management",
    "ExchangeRate": "Exchange Rate",
    "NetworkEconomics": "Network Economics",
    "Governance": "Governance",
    "NodeAdmin": "Node Admin",
    "ParticipantManagement": "Participant Management",
    "SubnetManagement": "Subnet Management",
    "NetworkCanisterManagement": "System Canister Management",
    "Kyc": "KYC",
    "NodeProviderRewards": "Node Provider Rewards",
    "SnsDecentralizationSale": "SNS Decentralization Swap",
    "IcOsVersionElection": "IC OS Version Election",
    "IcOsVersionDeployment": "IC OS Version Deployment",
    "SnsAndCommunityFund": "SNS & Neurons' Fund",
    "ApiBoundaryNodeManagement": "API Boundary Node Management",
    "SubnetRental": "Subnet Rental",
    "ProtocolCanisterManagement": "Protocol Canister Management",
    "ServiceNervousSystemManagement": "Service Nervous System Management"
  },
  "topics_description": {
    "Unspecified": "",
    "NeuronManagement": "A special topic by means of which a neuron can be managed by the followees for this topic (in this case, there is no fallback to default). Votes on this topic are not included in the voting history of the neuron. For proposals on this topic, only the neuron’s followees on the topic that the proposals pertain to are allowed to vote. Because the set of eligible voters of proposals on this topic is restricted, proposals on this topic have a shorter than normal voting period.",
    "ExchangeRate": "All proposals provide information in “real time” about the market value of ICP, as measured by an International Monetary Fund (IMF) Special Drawing Right (SDR) , which allows the NNS to convert ICP to cycles (which power computation) at a rate that keeps their real-world cost constant. Because proposals on this topic are very frequent, they have a shorter voting period, and votes on this topic are not included in the voting history of the neuron.",
    "NetworkEconomics": "Proposals that administer network economics — for example, determining what rewards should be paid to node providers.",
    "Governance": "All proposals that administer governance — for example, motions and the configuration of certain parameters.",
    "NodeAdmin": "All proposals that administer node machines somehow, including but not limited to upgrading or configuring the OS, upgrading or configuring the virtual machine framework, and upgrading or configuring the node replica software.",
    "ParticipantManagement": "All proposals that administer network participants — for example, granting and revoking DCIDs (data center identities) or NOIDs (node operator identities).",
    "SubnetManagement": "All proposals that administer network subnets — for example, creating new subnets, adding and removing subnet nodes, and splitting subnets.",
    "NetworkCanisterManagement": "Installing and upgrading “system” Canisters that belong to the network — for example, upgrading the NNS.",
    "Kyc": "Proposals that update KYC information for regulatory purposes — for example, during the initial Genesis distribution of ICP in the form of neurons.",
    "NodeProviderRewards": "Topic for proposals to reward node providers.",
    "SnsDecentralizationSale": "SNS Decentralization Swap.",
    "IcOsVersionElection": "Proposals handling election of IC OS versions.",
    "IcOsVersionDeployment": "Proposals handling deployments of IC OS versions.",
    "SnsAndCommunityFund": "Proposals relating to service nervous systems (SNS) and Neurons' Fund.",
    "ApiBoundaryNodeManagement": "Proposals related to the management of API boundary nodes.",
    "SubnetRental": "Proposals related to renting a subnet — for example a subnet rental request.",
    "ProtocolCanisterManagement": "Proposals related to managing canisters that are considered as part of the IC protocol.",
    "ServiceNervousSystemManagement": "All proposals related to managing the canisters related to service nervous system (SNS)."
  },
  "rewards": {
    "Unknown": "Unknown",
    "AcceptVotes": "Accepting Votes",
    "ReadyToSettle": "Ready to Settle",
    "Settled": "Settled",
    "Ineligible": "Ineligible"
  },
  "rewards_description": {
    "Unknown": "",
    "AcceptVotes": "The proposal is still accepting votes, for the purpose of voting rewards.",
    "ReadyToSettle": "The proposal is no longer accepting votes. It is due to settle in the next reward event.",
    "Settled": "The proposal has been taken into account in a reward event.",
    "Ineligible": "The proposal is not eligible to be taken into account in a reward event."
  },
  "status": {
    "Unknown": "Unknown",
    "Open": "Open",
    "Rejected": "Rejected",
    "Accepted": "Adopted",
    "Executed": "Executed",
    "Failed": "Failed"
  },
  "status_description": {
    "Unknown": "",
    "Open": "A decision has not yet been made to adopt or reject the proposal.",
    "Rejected": "The proposal has been rejected.",
    "Accepted": "The proposal has been adopted. Either execution has not yet started, or it has started but the outcome is not yet known.",
    "Executed": "The proposal was adopted and successfully executed.",
    "Failed": "The proposal was adopted, but execution failed."
  },
  "actions": {
    "RegisterKnownNeuron": "Register Known Neuron",
    "NeuronManagement": "Manage Neuron",
    "ApproveGenesisKyc": "Approve Genesis KYC",
    "ManageNetworkEconomics": "Manage Network Economics",
    "RewardNodeProvider": "Reward Node Provider",
    "RewardNodeProviders": "Reward Node Providers",
    "AddOrRemoveNodeProvider": "Add or Remove Node Provider",
    "SetDefaultFollowees": "Set Default Followees",
    "Motion": "Motion",
    "SetSnsTokenSwapOpenTimeWindow": "Start Decentralization Swap",
    "OpenSnsTokenSwap": "Open Decentralization Swap",
    "CreateServiceNervousSystem": "Create Service Nervous System (SNS)",
    "InstallCode": "Install Code",
    "StopOrStartCanister": "Stop or Start Canister",
    "UpdateCanisterSettings": "Update Canister Settings"
  },
  "actions_description": {
    "RegisterKnownNeuron": "This proposal registers an existing neuron as a “known neuron,” giving it a name and an optional description, and adding the neuron to the list of known neurons.",
    "NeuronManagement": "This type of proposal calls a major function on a specified target neuron. Only the followees of the target neuron may vote on these proposals, which effectively provides the followees with control over the target neuron. This can provide a convenient and \nhighly secure means for a team of individuals to manage an important neuron. For example, a neuron might hold a large balance, or belong to an organization of high repute, and be publicized so that many other neurons can follow its vote. In both cases, managing the private key of the principal securely could be problematic. (Either a single copy is held, which is very insecure and provides for a single party to take control, or a group of individuals must divide responsibility — for example, using threshold cryptography, which is complex and time consuming). To address this using this proposal type, the important neuron can be configured to follow the neurons controlled by individual members of a team. Now they can submit proposals to make the important neuron perform actions, which are adopted if and only if a majority of them vote to adopt. (Submitting such a proposal costs a small fee, to prevent denial-of-service attacks.) Nearly any command on the target neuron can be executed, including commands that change the follow rules, allowing the set of team members to be dynamic. Only the final step of dissolving the neuron once its dissolve delay reaches zero cannot be performed using this type of proposal, since this would allow control/“ownership” over the locked balances to be transferred. (The only exception to this rule applies to not-for-profit organizations, which may be allowed to dissolve their neurons without using the initial private key.) To prevent a neuron falling under the malign control of the principal’s private key by accident, the private key can be destroyed so that the neuron can only be controlled by its followees, although this makes it impossible to subsequently unlock the balance.",
    "ApproveGenesisKyc": "When new neurons are created at Genesis, they have GenesisKYC=false. This restricts what actions they can perform. Specifically, they cannot spawn new neurons, and once their dissolve delays are zero, they cannot be disbursed and their balances unlocked to new accounts. This proposal sets GenesisKYC=true for batches of principals.<br/>(<i>Special note:</i> The Genesis event disburses all ICP in the form of neurons, whose principals must be KYCed. Consequently, all neurons created after Genesis have GenesisKYC=true set automatically since they must have been derived from balances that have already been KYCed.)",
    "ManageNetworkEconomics": "This is a single proposal type which can update one or several economic parameters:<br/>• <b>Reject cost: </b>The amount of ICP the proposer of a rejected proposal will be charged — to prevent the spamming of frivolous proposals.<br/><b>Minimum Neuron Stake: </b>Set the minimum number of ICP required for creation of a neuron. The same limit must also be respected when increasing dissolve delay or changing the neuron state from dissolving to aging.<br/>• <b>Neuron Management fee: </b>The cost in ICP per neuron management proposal. Here the NNS is doing work on behalf of a specific neuron, and a small fee will be applied to prevent overuse of this feature (i.e., spam).<br/>• <b>Minimum ICP/SDR rate: </b>To prevent mistakes, there is a lower bound for the ICP/SDR rate, managed by network economic proposals.<br/>• <b>Dissolve delay of spawned neurons: </b>The dissolve delay of a neuron spawned from the maturity of an existing neuron.<br/>• <b>Maximum node provider rewards: </b>The maximum rewards to be distributed to node providers in a single distribution event (proposal).<br/>• <b>Transaction fee: </b>The transaction fee that must be paid for each ledger transaction.<br/>• <b>Maximum number of proposals to keep per topic: </b>The maximum number of proposals to keep, per topic. When the total number of proposals for a given topic is greater than this number, the oldest proposals that have reached a “final” state may be deleted to save space.",
    "RewardNodeProvider": "A proposal to reward a node provider an amount of ICP as compensation for providing nodes to the IC.",
    "RewardNodeProviders": "A proposal to reward multiple node providers an amount of ICP as compensation for providing nodes to the IC.",
    "AddOrRemoveNodeProvider": "Assign (or revoke) an identity to a node provider, associating key information regarding the legal person associated that should provide a way to uniquely identify it.",
    "SetDefaultFollowees": "Specify the list of followees that a freshly created neuron should have.",
    "Motion": "A motion is a text that can be adopted or rejected. No code is executed when a motion is adopted. An adopted motion should guide the future strategy of the Internet Computer ecosystem.",
    "SetSnsTokenSwapOpenTimeWindow": "Start decentralization swap.",
    "OpenSnsTokenSwap": "Open decentralization swap.",
    "CreateServiceNervousSystem": "Create a new Service Nervous System (SNS).",
    "InstallCode": "Calls install_code for a canister (install, reinstall, or upgrade).",
    "StopOrStartCanister": "Stops or starts a canister controlled by NNS Root.",
    "UpdateCanisterSettings": "Updates settings of a canister controlled by NNS Root (or NNS Root itself)."
  },
  "nns_functions": {
    "Unspecified": "Unspecified",
    "CreateSubnet": "Create Subnet",
    "AddNodeToSubnet": "Add Node to Subnet",
    "NnsCanisterInstall": "NNS Canister Install",
    "NnsCanisterUpgrade": "NNS Canister Upgrade",
    "BlessReplicaVersion": "Bless Replica Version",
    "RecoverSubnet": "Recover Subnet",
    "UpdateConfigOfSubnet": "Update Subnet Config",
    "AssignNoid": "Assign Node Operator ID (NOID)",
    "NnsRootUpgrade": "NNS Root Canister Upgrade",
    "IcpXdrConversionRate": "ICP/XDR Conversion Rate",
    "UpdateSubnetReplicaVersion": "Deploy GuestOS To All Subnet Nodes",
    "ClearProvisionalWhitelist": "Clear Provisional Whitelist",
    "RemoveNodesFromSubnet": "Remove Node from Subnet",
    "SetAuthorizedSubnetworks": "Set Authorized Subnets",
    "SetFirewallConfig": "Set Firewall Config",
    "UpdateNodeOperatorConfig": "Update Node Operator Config",
    "StopOrStartNnsCanister": "Stop or Start NNS Canister",
    "RemoveNodes": "Remove Nodes from Registry",
    "UninstallCode": "Uninstall Code",
    "UpdateNodeRewardsTable": "Update Node Rewards Table",
    "AddOrRemoveDataCenters": "Add or Remove Data Centers",
    "UpdateUnassignedNodesConfig": "Update Unassigned Nodes Config",
    "RemoveNodeOperators": "Remove Node Operators",
    "RerouteCanisterRanges": "Reroute Canister Ranges",
    "AddFirewallRules": "Add Firewall Rules",
    "RemoveFirewallRules": "Remove Firewall Rules",
    "UpdateFirewallRules": "Update Firewall Rules",
    "PrepareCanisterMigration": "Prepare Canister Migration",
    "CompleteCanisterMigration": "Complete Canister Migration",
    "AddSnsWasm": "Bless New SNS Deployment",
    "ChangeSubnetMembership": "Change Subnet Membership",
    "UpdateSubnetType": "Update Subnet Type",
    "ChangeSubnetTypeAssignment": "Change Subnet Type Assignment",
    "UpdateSnsWasmSnsSubnetIds": "Update SNS-WASM Subnet Ids",
    "UpdateAllowedPrincipals": "Update Allowed Principals",
    "RetireReplicaVersion": "Retire Replica Version",
    "InsertSnsWasmUpgradePathEntries": "Insert SNS-WASM Upgrade Path Entries",
    "UpdateElectedReplicaVersions": "Revise Elected GuestOS Versions",
    "BitcoinSetConfig": "Set Bitcoin Config",
    "UpdateElectedHostosVersions": "Update Elected HostOS Versions",
    "UpdateNodesHostosVersion": "Update Nodes HostOS Version",
    "AddApiBoundaryNode": "Add API Boundary Nodes",
    "RemoveApiBoundaryNodes": "Remove API Boundary Nodes",
    "UpdateApiBoundaryNodesVersion": "Update API Boundary Nodes Version",
    "DeployGuestosToSomeApiBoundaryNodes": "Deploy GuestOS To Some API Boundary Nodes",
    "DeployGuestosToAllUnassignedNodes": "Deploy GuestOS To All Unassigned Nodes",
    "UpdateSshReadOnlyAccessForAllUnassignedNodes": "Update SSH Read Only Access For All Unassigned Nodes",
    "ReviseElectedHostosVersions": "Revise Elected HostOS Versions",
    "DeployHostosToSomeNodes": "Deploy HostOS To Some Nodes",
    "SubnetRentalRequest": "Subnet Rental Request"
  },
  "nns_functions_description": {
    "Unspecified": "",
    "CreateSubnet": "Combine a specified set of nodes, typically drawn from data centers and operators in such a way as to guarantee their independence, into a new decentralized subnet. The execution of this external update first initiates a new instance of the distributed key generation protocol. The transcript of that protocol is written to a new subnet record in the registry, together with initial configuration information for the subnet, from where the nodes comprising the subnet pick it up.",
    "AddNodeToSubnet": "Add a new node to a subnet. The node cannot be currently assigned to a subnet. The execution of this proposal changes an existing subnet record to add a node. From the perspective of the NNS, this update is a simple update of the subnet record in the registry.",
    "NnsCanisterInstall": "A proposal to add a new canister to be installed and executed in the NNS subnetwork. The root canister, which controls all Canisters on the NNS except for itself, handles this proposal type. The call also expects the Wasm module that shall be installed.",
    "NnsCanisterUpgrade": "A proposal to upgrade an existing canister in the NNS subnetwork. This proposal type is executed by the root canister. Beyond upgrading the Wasm module of the target canister, the proposal can also set the authorization information and the allocations.",
    "BlessReplicaVersion": "A proposal to bless a new version to which the replicas can be upgraded. The proposal registers a replica version (identified by the hash of the installation image) in the registry. Besides creating a record for that version, the proposal also appends that version to the list of “blessed versions” that can be installed on a subnet. By itself, this proposal does not affect any upgrade. (In the future, there will only be one blessed version of the replica software at any given time.)",
    "RecoverSubnet": "Update a subnet’s recovery CUP (used to recover subnets that have stalled). Nodes that find a recovery CUP for their subnet will load that CUP from the registry and restart the replica from that CUP.",
    "UpdateConfigOfSubnet": "Update a subnet’s configuration. This proposal updates the subnet record in the registry, with the changes being picked up by the nodes on the subnet when they reference the respective registry version. Subnet configuration comprises protocol parameters that must be consistent across the subnet (e.g., message sizes).",
    "AssignNoid": "Assign an identity to a node operator associating key information regarding its ownership, the jurisdiction in which it is located, and other information. The node operator is stored as a record in the registry. It contains the remaining node allowance for that node operator, that is the number of nodes the node operator can still add to the IC. When an additional node is added by the node operator, the remaining allowance is decreased.",
    "NnsRootUpgrade": "A proposal to upgrade the root canister in the NNS subnetwork. The proposal is processed by the Lifeline canister, which controls the root canister. The proposal updates the Wasm module as well as the authorization settings.",
    "IcpXdrConversionRate": "Instruct the NNS about the market value of 1 ICP as measured by an IMF SDR. This setting affects cycles pricing (as the value of cycles shall be constant with respect to IMF SDRs).",
    "UpdateSubnetReplicaVersion": "Deploy a GuestOS version to a given subnet. The proposal changes the GuestOS version that is used on the specified subnet.<br/><br/>The version must be contained in the list of elected GuestOS versions.<br/><br/>The upgrade is completed when the subnet creates the next regular CUP.",
    "ClearProvisionalWhitelist": "Clears the provisional whitelist, which allows the listed principals to create Canisters with cycles. The mechanism is only needed for bootstrap and testing and must be deactivated afterward.",
    "RemoveNodesFromSubnet": "Remove a node from a subnet. It then becomes available for reassignment. The execution of this proposal changes an existing subnet record to remove a node. From the perspective of the NNS, this update is a simple update of the subnet record in the registry.",
    "SetAuthorizedSubnetworks": "Informs the cycles minting canister that a certain principal is authorized to use certain subnetworks (from a list). Can also be used to set the “default” list of subnetworks that principals without special authorization are allowed to use.",
    "SetFirewallConfig": "Change the Firewall configuration in the registry (configures which boundary nodes subnet blockchain replicas will communicate with).",
    "UpdateNodeOperatorConfig": "Change a Node Operator’s allowance in the registry.",
    "StopOrStartNnsCanister": "Stop or start an NNS canister.",
    "RemoveNodes": "Remove unassigned nodes from the registry.",
    "UninstallCode": "Uninstall code of a canister.",
    "UpdateNodeRewardsTable": "Update the node rewards table.",
    "AddOrRemoveDataCenters": "Add or remove Data Center records.",
    "UpdateUnassignedNodesConfig": "Update the configuration for all unassigned nodes.",
    "RemoveNodeOperators": "Remove node operator records from the registry.",
    "RerouteCanisterRanges": "In the routing table in the registry, remap canister ID ranges from one subnet to a different subnet.<br/><br/>The steps of canister migration are:<ol><li>Prepare Canister Migration</li><li>Reroute Canister Ranges</li><li>Complete Canister Migration</li></ol>",
    "AddFirewallRules": "Add firewall rules in the registry. Nodes use a firewall to protect themselves from network attacks.",
    "RemoveFirewallRules": "Remove firewall rules in the registry. Nodes use a firewall to protect themselves from network attacks.",
    "UpdateFirewallRules": "Update firewall rules in the registry. Nodes use a firewall to protect themselves from network attacks.",
    "PrepareCanisterMigration": "Insert or update canister migrations entries. Such entries specify that a migration of canister ID ranges is currently ongoing.<br/><br/>The steps of canister migration are:<ol><li>Prepare Canister Migration</li><li>Reroute Canister Ranges</li><li>Complete Canister Migration</li></ol>",
    "CompleteCanisterMigration": "Remove canister migrations entries. Such entries specify that a migration of canister ID ranges is currently ongoing.<br/><br/>The steps of canister migration are:<ol><li>Prepare Canister Migration</li><li>Reroute Canister Ranges</li><li>Complete Canister Migration</li></ol>",
    "AddSnsWasm": "Add a new SNS canister WASM.",
    "ChangeSubnetMembership": "Change the membership (list) of nodes in a subnet by adding and/or removing nodes from the subnet. At the time the proposal is executed, the added nodes (if provided in the proposal) need to be unassigned and the removed nodes (if provided in the proposal) need to be assigned to the subnet. After the proposal is executed, the removed nodes become unassigned, and can be reassigned to other subnets via future proposals or completely removed from the network.",
    "UpdateSubnetType": "Add or remove a subnet type. A new subnet type can be added if it doesn’t already exist. An existing subnet type can be removed if no subnets are assigned to it. Subnet types can be used to choose the kind of subnet a canister should be created on.",
    "ChangeSubnetTypeAssignment": "Change the assignment of subnets to subnet types by either adding subnets to or removing subnets from a subnet type. A subnet can be assigned to a subnet type if the subnet is not already assigned to a different subnet type and is not already in the authorized subnets list (i.e., subnets authorized for certain principals) or the default subnets list (i.e., default subnets that new canisters are randomly created on). Once a subnet is assigned to a subnet type, it becomes available to users who can specify that they want their canisters to be created on subnets of that type.",
    "UpdateSnsWasmSnsSubnetIds": "Update the list of SNS subnet IDs that SNS-WASM will deploy SNS instances to.",
    "UpdateAllowedPrincipals": "Update the SNS-WASM canister's list of allowed principals. This list guards which principals can deploy an SNS.",
    "RetireReplicaVersion": "A proposal to retire previously elected and unused replica versions. The specified versions are removed from the list of blessed replica versions in the registry. This ensures that a replica can no longer be upgraded to these versions. The proposal will fail to remove replica version if that version is currently used by a subnet or unassigned node.",
    "InsertSnsWasmUpgradePathEntries": "Insert custom upgrade path entries into SNS-WASM for all SNSs, or for an SNS specified by its governance canister ID.",
    "UpdateElectedReplicaVersions": "A proposal to change the set of elected GuestOS versions.<br/><br/>The version to elect (identified by the hash of the installation image) is added to the registry. Besides creating a record for that version, the proposal also appends that version to the list of elected versions that can be installed on nodes of a subnet.<br/><br/>Only elected GuestOS versions can be deployed.",
    "BitcoinSetConfig": "A proposal to set the configuration of the underlying Bitcoin Canister that powers the Bitcoin API. The configuration includes whether or not the Bitcoin Canister should sync new blocks from the network, whether the API is enabled, the fees to charge, etc.",
    "UpdateElectedHostosVersions": "A proposal to update currently elected HostOS versions, by electing a new version, and/or unelecting multiple unused versions. The version to elect (often identified by the hash of the installation image) is added to the registry. By itself, this proposal does not effect any upgrade. The specified versions to unelect are removed from the registry. This ensures that the HostOS cannot upgrade to these versions anymore.",
    "UpdateNodesHostosVersion": "Update the HostOS version running on a given list of nodes. The proposal changes the HostOS version that is used on the specified nodes. The version must be contained in the list of HostOS versions.",
    "AddApiBoundaryNode": "A proposal to add a set of new API Boundary Nodes using unassigned nodes.",
    "RemoveApiBoundaryNodes": "A proposal to remove a set of API Boundary Nodes, which will designate them as unassigned nodes.",
    "UpdateApiBoundaryNodesVersion": "A proposal to update the version of a set of API Boundary Nodes.",
    "DeployGuestosToSomeApiBoundaryNodes": "A proposal to update the version of a set of API Boundary Nodes.",
    "DeployGuestosToAllUnassignedNodes": "A proposal to update the version of all unassigned nodes.",
    "UpdateSshReadOnlyAccessForAllUnassignedNodes": "A proposal to update SSH readonly access for all unassigned nodes.",
    "ReviseElectedHostosVersions": "A proposal to change the set of currently elected HostOS versions, by electing a new version, and/or unelecting some priorly elected versions.<br/><br/>HostOS versions are identified by the hash of the installation image.<br/><br/>The version to elect is added to the Registry, and the versions to unelect are removed from the Registry, ensuring that HostOS cannot upgrade to these versions anymore.<br/><br/>This proposal does not actually perform the upgrade; for deployment of an elected version, please refer to \"Deploy HostOS To Some Nodes\".",
    "DeployHostosToSomeNodes": "Deploy a HostOS version to a given set of nodes. The proposal changes the HostOS version that is used on the specified nodes.",
    "SubnetRentalRequest": "A proposal to rent a subnet on the Internet Computer.<br/><br/>The Subnet Rental Canister is called when this proposal is executed, and the rental request is stored there. The user specified in the proposal needs to make a sufficient upfront payment in ICP in order for the proposal to be valid, and the subnet must be available for rent. The available rental conditions can be checked by calling the Subnet Rental Canister."
  }
}
