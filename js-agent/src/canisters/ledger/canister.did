type ICPTs = record {
     doms : nat64;
};

type BlockHeight = nat64;
type Certification = opt vec nat8;
type Memo = nat64;
type SystemTime = nat64;
type AccountIdentifier = text;
type SubAccount = vec nat8;
type EncodedBlock = vec nat8;

type Block = record {
    transaction: Transaction;
    timestamp: SystemTime;
};

type Transfer = variant {
    Burn: record {
        from: AccountIdentifier;
        amount: ICPTs;
    };
    Mint: record {
        to: AccountIdentifier;
        amount: ICPTs;
    };
    Send: record {
        from: AccountIdentifier;
        to: AccountIdentifier;
        amount: ICPTs;
    };
};

type Transaction = record {
    transfer: Transfer;
    memo: Memo;
    created_at: BlockHeight;
};

type SendArgs = record {
    memo: Memo;
    amount: ICPTs;
    fee: ICPTs;
    from_subaccount: opt SubAccount;
    to: AccountIdentifier;
    block_height: opt BlockHeight;
};

type NotifyCanisterArgs = record {
    block_height: BlockHeight;
    max_fee: ICPTs;
    from_subaccount: opt SubAccount;
    to_canister: principal;
    to_subaccount: opt SubAccount;
};

type AccountBalanceArgs = record {
    account: AccountIdentifier;
};

type TotalSupplyArgs = record {};

type LedgerCanisterInitPayload = record {
    minting_account: AccountIdentifier;
    initial_values: vec record {AccountIdentifier; ICPTs};
    archive_canister: opt principal;
    max_message_size_bytes: opt nat32;
}

service: (LedgerCanisterInitPayload) -> {
  send : (SendArgs) -> (BlockHeight);
  notify: (NotifyCanisterArgs) -> ();
  account_balance : (AccountBalanceArgs) -> (ICPTs) query;
  total_supply: (TotalSupplyArgs) -> (ICPTs) query;
  tip_of_chain : () -> (Certification, BlockHeight) query;
  block : (BlockHeight) -> (opt EncodedBlock) query;
}
