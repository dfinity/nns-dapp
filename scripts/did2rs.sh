#!/usr/bin/env bash
set -euo pipefail
SOURCE_DIR="$(dirname "$(realpath "${BASH_SOURCE[0]}")")"
PATH="$SOURCE_DIR:$PATH"

##########################
# Hjelpe meg!
##########################
print_help() {
  cat <<-EOF
	Compiles a did file to Rust and applies any saved manual changes.

	Usage: $(basename "$0") <CANISTER_NAME>
	takes inputs:
	  declarations/<CANISTER_NAME>/<CANISTER_NAME>.did
	  rs/sns_aggregator/src/types/<CANISTER_NAME>.patch (optional)
	creates:
	  rs/sns_aggregator/src/types/<CANISTER_NAME>.rs

	Hint: To create a patchfile:
	  - Customise the built rust file to your heart's content.
	  - Commit the modified file.
	  - Remove any existing patchfile.
	  - Make a clean build (this will undo your changes)
	  - Run: git diff -R \$CANISTER_NAME.rs > \CANISTER_NAME.patch
	  - Check out the rust file to recover your changes.
	  - Now, rebuilding should create a file with your changes.

	EOF
}

# Source the clap.bash file ---------------------------------------------------
source "$SOURCE_DIR/clap.bash"
# Define options
clap.define short=c long=canister desc="The canister name" variable=CANISTER_NAME
clap.define short=d long=did desc="The did path.  Default: {GIT_ROOT}/declarations/{CANISTER_NAME}/{CANISTER_NAME}.did" variable=DID_PATH
# Source the output file ----------------------------------------------------------
source "$(clap.build)"

##########################
# Get working dir and args
##########################
CANISTER_NAME="${CANISTER_NAME:-${1:-${DID_PATH:-}}}"
CANISTER_NAME="$(basename "${CANISTER_NAME%.did}")"
GIT_ROOT="$(git rev-parse --show-toplevel)"

RUST_PATH="${GIT_ROOT}/rs/sns_aggregator/src/types/ic_${CANISTER_NAME}.rs"
PATCH_PATH="${GIT_ROOT}/rs/sns_aggregator/src/types/ic_${CANISTER_NAME}.patch"
DID_PATH="${DID_PATH:-${GIT_ROOT}/declarations/${CANISTER_NAME}/${CANISTER_NAME}.did}"

cd "$GIT_ROOT"

: "Ensure that tools are installed and working.  Rustfmt in particular can self-upgrade when called and the self-upgrade can fail."
{
  didc --version
  rustfmt --version
} >/dev/null

##########################
# Translate candid to Rust
##########################
{
  # Here we write the first few lines of the Rust file.
  #
  # This is autogenerated code.  We allow the following:
  #   - Some field names in the API do not follow the Rust naming convention.
  #   - We do not allow the formatter to alter the files, as that would break the patch files.
  #   - Types and fields may be unused or not exactly as clippy might wish.  Tough.
  #
  # We import traits that we apply to the Rust types.
  cat <<-EOF
	#![allow(clippy::all)]
	#![allow(unused_imports)]
	#![allow(clippy::missing_docs_in_private_items)]
	#![allow(non_camel_case_types)]
	#![allow(dead_code)]

	use crate::types::{CandidType, Deserialize, EmptyRecord, Serialize};
	use ic_cdk::api::call::CallResult;
	EOF
  # didc converts the .did to Rust, with the following limitations:
  #   - It applies the canidid Deserialize trait to all the types but not other traits that we need.
  #   - It makes almost all the types and fields private, which is not very helpful.
  #
  # sed:
  #   - Comments out the header provided by didc; we provide our own and the two conflict.
  #   - Makes structures and their fields "pub", so that they can be used.
  #   - Adds additional traits after "Deserialize".
  #   - Makes API call response types "CallResult".  The alternative convention is to have:
  #       use ic_cdk::api::call::CallResult as Result;
  #     at the top of the rust file but that is both confusing for Rust developers and conflicts
  #     with custom definitions of Result found in some did files.
  #   - didc creates invalid Rust enum entries of the form: `StopDissolving{},`
  #     These are changed to legal Rust: `StopDissolving(EmptyRecord),`
  #     where "EmptyRecord" is defined as the name suggests.
  #   - Deprecated: Uses `candid::Principal` instead of `Principal`.
  #
  # Final tweaks are defined manually and encoded as patch files.  The changes typically include:
  #   - Replacing the anonymous result{} type in enums with EmptyRecord.  didc produces valid rust code, but
  #     in a form that the Candid macro cannot handle.  Using a named type works around the limit of the macro.
  #   - We need a few but not all of the types to have the Default macro
  #   - Any corrections to the output of the sed script.  sed is not a Rust parser; the sed output
  #     is not guaranteed to be correct.
  # shellcheck disable=SC2016
  didc bind "${DID_PATH}" --target rs |
    rustfmt --edition 2021 |
    sed -E '
            # Comment out the header "use" lines.  Leave "//!" and "#!" for now.
            s@^use .*@// &@;

	    # Make types and fields public:
            s/^(struct|enum|type) /pub &/;
            s/^    [a-z].*:/    pub&/;s/^( *pub ) *pub /\1/;

	    # Add traits
            s/([{( ]Deserialize)([,})])/\1, Serialize, Clone, Debug\2/;

	    # In the service, return CallResult instead of Result.
	    /impl Service/,${s/-> Result/-> CallResult/g};

	    # Replace invalid "{}" in generated Rust code with "EmptyRecord":
	    /^pub (struct|enum) /,/^}/{s/ *\{\},$/(EmptyRecord),/g};

	    # Use candid::Principal instead of raw Principal
	    s/\<Principal\>/candid::&/g;
	    ' |
    rustfmt --edition 2021
} >"${RUST_PATH}"
if test -f "${PATCH_PATH}"; then
  (
    patch -p1 <"${PATCH_PATH}"
  )
fi
