#!/usr/bin/env bash
set -euo pipefail

SOURCE_DIR="$(dirname "$(realpath "${BASH_SOURCE[0]}")")"

print_help() {
  cat <<-EOF

	Installs a snapshot of local replica state as saved by
  https://github.com/dfinity/snsdemo/blob/main/bin/dfx-state-save .
  Before doing so, it moves existing state directories into a backup directory
  and creates a 'restore.sh' script to restore everything to their original
  locations, in the same backup directory.
	EOF
}

UNSET_BACKUP_DIR="$HOME/dfx-state-backup-generated-timestamp"

# Source the clap.bash file ---------------------------------------------------
source "$SOURCE_DIR/clap.bash"
# Define options
clap.define short=s long=snapshot desc="The snapshot .tar.xz or .zip file" variable=SNAPSHOT_ARCHIVE default="snapshot.tar.xz"
clap.define short=b long=backup-dir desc="The backup directory to create" variable=BACKUP_DIR_ARG default="$UNSET_BACKUP_DIR"
clap.define short=c long=clean desc="Extract a clean state from the .zip file, even if a cached directory with extracted state exists" variable=CLEAN nargs=0 default="false"
# Source the output file ----------------------------------------------------------
source "$(clap.build)"

if ls -ld "$HOME"/dfx-state-backup-* 2>/dev/null; then
  echo "ERROR: Found existing backup directory. Restore the previous backup before installing a new snapshot."
  exit 1
fi

if [ ! -f "$SNAPSHOT_ARCHIVE" ]; then
  echo "Snapshot file $SNAPSHOT_ARCHIVE does not exist. Use --snapshot to specify a snapshot .tar.xz or .zip file as generated by dfx-snapshot-save in the snsdemo repo."
  exit 1
fi

extract() {
  ARCHIVE="$1"
  DESTINATION_DIR="$2"
  if [ "${ARCHIVE%.zip}" != "$ARCHIVE" ]; then
    unzip "$ARCHIVE" -d "$DESTINATION_DIR"
  elif [ "${ARCHIVE%.tar.xz}" != "$ARCHIVE" ]; then
    tar --extract --xz --file "$ARCHIVE" --directory "$DESTINATION_DIR"
  else
    echo "ERROR: Only .tar.xz and .zip snapshots are supported."
    exit 1
  fi
}

STATE_HASH="$(sha256sum "$SNAPSHOT_ARCHIVE" | cut -d' ' -f1)"

OLD_STATE_DIR="$(find "$(dirname "$(dfx cache show)")" -name "snsdemo-state-$STATE_HASH" | sort | tail -1)"
PREFERRED_STATE_DIR="$HOME/.snsdemo-state/$STATE_HASH"

if [ -d "$OLD_STATE_DIR" ] && ! [ -d "$PREFERRED_STATE_DIR" ]; then
  echo "Using state from old location: $OLD_STATE_DIR"
  STATE_DIR="$OLD_STATE_DIR"
else
  STATE_DIR="$PREFERRED_STATE_DIR"
fi

if [ -d "$STATE_DIR" ] && [ "$CLEAN" = "false" ]; then
  echo "Reusing existing state in $STATE_DIR"
else
  if [ -d "$STATE_DIR" ]; then
    echo "Removing existing state in $STATE_DIR"
    rm -rf "$STATE_DIR"
    # Once the directorly is deleted, we can use the preferred state directory.
    STATE_DIR="$PREFERRED_STATE_DIR"
  fi
  echo "Extracting state into $STATE_DIR"
  mkdir -p "$STATE_DIR"
  extract "$SNAPSHOT_ARCHIVE" "$STATE_DIR"
fi

TOP_DIR=$(git rev-parse --show-toplevel)

if [ "$(uname)" = "Darwin" ]; then
  RELATIVE_DFX_LOCAL_REPLICA_DATA_DIR="Library/Application Support/org.dfinity.dfx/network/local"
else
  RELATIVE_DFX_LOCAL_REPLICA_DATA_DIR=".local/share/dfx/network/local"
fi

# DFX_LOCAL_REPLICA_DATA_DIR is used by get_dfx_dir.
# shellcheck disable=SC2034
DFX_LOCAL_REPLICA_DATA_DIR="$HOME/$RELATIVE_DFX_LOCAL_REPLICA_DATA_DIR"
# DFX_LOCAL_REPLICA_DATA_STATE_DIR is used by get_state_dir.
# shellcheck disable=SC2034
DFX_LOCAL_REPLICA_DATA_STATE_DIR="$STATE_DIR/$RELATIVE_DFX_LOCAL_REPLICA_DATA_DIR"

# DFX_CONFIG_DIR is used by get_dfx_dir.
# shellcheck disable=SC2034
DFX_CONFIG_DIR="$HOME/.config/dfx"
# DFX_NETWORK_DIR is used by get_dfx_dir.
# shellcheck disable=SC2034
DFX_NETWORK_DIR="$TOP_DIR/.dfx"

if [ "$BACKUP_DIR_ARG" = "$UNSET_BACKUP_DIR" ]; then
  BACKUP_DIR="$HOME/dfx-state-backup-$(date +"%Y%m%d_%H%M%S")"
else
  BACKUP_DIR="$BACKUP_DIR_ARG"
fi
mkdir -p "$BACKUP_DIR"

# DFX_LOCAL_REPLICA_DATA_BACKUP_DIR is used by get_backup_dir.
# shellcheck disable=SC2034
DFX_LOCAL_REPLICA_DATA_BACKUP_DIR="$BACKUP_DIR/data"
# DFX_CONFIG_BACKUP_DIR is used by get_backup_dir.
# shellcheck disable=SC2034
DFX_CONFIG_BACKUP_DIR="$BACKUP_DIR/config"
# DFX_NETWORK_BACKUP_DIR is used by get_backup_dir.
# shellcheck disable=SC2034
DFX_NETWORK_BACKUP_DIR="$BACKUP_DIR/network"

# DFX_CONFIG_STATE_DIR is used by get_state_dir.
# shellcheck disable=SC2034
DFX_CONFIG_STATE_DIR="$STATE_DIR/.config/dfx"
# DFX_NETWORK_STATE_DIR is used by get_state_dir.
# shellcheck disable=SC2034
DFX_NETWORK_STATE_DIR="$STATE_DIR/.dfx"

# Takes "LOCAL_REPLICA_DATA", "CONFIG", or "NETWORK" as argument and returns the
# value of $DFX_LOCAL_REPLICA_DATA_DIR, $DFX_CONFIG_DIR, or $DFX_NETWORK_DIR
# correspondingly.
get_dfx_dir() {
  var_name="DFX_${1}_DIR"
  echo "${!var_name}"
}

# Takes "LOCAL_REPLICA_DATA", "CONFIG", or "NETWORK" as argument and returns the
# value of $DFX_LOCAL_REPLICA_DATA_BACKUP_DIR, $DFX_CONFIG_BACKUP_DIR, or
# $DFX_NETWORK_BACKUP_DIR correspondingly.
get_backup_dir() {
  var_name="DFX_${1}_BACKUP_DIR"
  echo "${!var_name}"
}

# Takes "LOCAL_REPLICA_DATA", "CONFIG", or "NETWORK" as argument and returns the
# value of $DFX_LOCAL_REPLICA_DATA_STATE_DIR, $DFX_CONFIG_STATE_DIR, or
# $DFX_NETWORK_STATE_DIR correspondingly.
get_state_dir() {
  var_name="DFX_${1}_STATE_DIR"
  echo "${!var_name}"
}

reverse_restore_commands=()

mkdir_and_restore() {
  if [[ -e "$1" ]]; then
    return
  fi
  mkdir_and_restore "$(dirname "$1")"
  printf 'mkdir %q\n' "$1"
  mkdir "$1"
  reverse_restore_commands+=("$(printf "rmdir %q" "$1")")
}

mv_and_restore() {
  mkdir_and_restore "$(dirname "$2")"
  printf 'mv %q %q\n' "$1" "$2"
  mv "$1" "$2"
  reverse_restore_commands+=("$(printf "mv %q %q" "$2" "$1")")
}

# Moves $2 to $3 and then $1 to $2.
# Returns an error if $3 already exists but silently skips moves for which the
# source doesn't exist.
mv3() {
  if [ -e "$3" ]; then
    echo "$3 already exists"
    return 1
  fi
  if [ -e "$2" ]; then
    mv_and_restore "$2" "$3"
  fi
  if [ -e "$1" ]; then
    mv_and_restore "$1" "$2"
  fi
}

# Takes "LOCAL_REPLICA_DATA", "CONFIG", or "NETWORK" as argument and moves the
# corresponding directory to the backup location and the corresponding state
# directory in its place.
install_dir() {
  state_dir="$(get_state_dir "$1")"
  dfx_dir="$(get_dfx_dir "$1")"
  backup_dir="$(get_backup_dir "$1")"
  mv3 "$state_dir" "$dfx_dir" "$backup_dir"
}

get_config_paths_to_install() {
  # Shellcheck suggests using find instead of ls but that makes the code much
  # more complicated and I don't expect any non-standard characters in these
  # files.
  # shellcheck disable=SC2010
  ls "$DFX_CONFIG_STATE_DIR" | grep -v '^identity$'
  # shellcheck disable=SC2012
  ls "$DFX_CONFIG_STATE_DIR/identity" | sed -e 's@^@identity/@'
}

install_config_dir() {
  for config_path in $(get_config_paths_to_install); do
    mv3 "${DFX_CONFIG_STATE_DIR}/${config_path}" "${DFX_CONFIG_DIR}/${config_path}" "${DFX_CONFIG_BACKUP_DIR}/${config_path}"
  done
}

# Moves all the existing directories to the backup location and moves the state
# directories in their place.
install_state() {
  install_dir LOCAL_REPLICA_DATA
  install_config_dir
  install_dir NETWORK
}

output_restore_backup_script() {
  cat <<-EOF
	if pgrep -q -x replica || pgrep -q -x pocket-ic; then
	  echo "A replica is still running. State should be restored automatically when the replica is stopped." >&2
	  exit 1
	fi
	echo "Restoring dfx state."
	set -xeu
	EOF
  for ((i = ${#reverse_restore_commands[@]} - 1; i >= 0; i--)); do
    printf "%s\n" "${reverse_restore_commands[i]}"
  done
  echo rm "\$0"
  echo rmdir "$BACKUP_DIR"
}

# We put the backup script inside the backup directory.
# So if for whatever reason the script fails to restore the backup, we can
# manually call the script to resore the backup.
RESTORE_BACKUP_SCRIPT_FILE="$BACKUP_DIR/restore.sh"
echo "Run $RESTORE_BACKUP_SCRIPT_FILE to restore the replica state."

trap 'output_restore_backup_script >"$RESTORE_BACKUP_SCRIPT_FILE"' EXIT

install_state
